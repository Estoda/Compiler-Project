%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "parser.tab.h"   /* generated by bison -d parser.y */

#define MAX_SIZE 100 // Maximum size for the key-value map

void yyerror(char *);
int num_of_v = 0;

struct KeyValue {
    char key[64];
    int value;
};

struct KeyValue myMap[MAX_SIZE];

void addToMap(const char *key, int value)
{
    for (int i = 0; i < MAX_SIZE; ++i) {
        if (myMap[i].key[0] != '\0' && strcmp(myMap[i].key, key) == 0) {
            myMap[i].value = value;
            return;
        }
    }
    for (int i = 0; i < MAX_SIZE; ++i) {
        if (myMap[i].key[0] == '\0') {
            strncpy(myMap[i].key, key, sizeof(myMap[i].key)-1);
            myMap[i].key[sizeof(myMap[i].key)-1] = '\0';
            myMap[i].value = value;
            return;
        }
    }
    fprintf(stderr, "Error: Map is full\n");
    yyerror("Error: Map is full");
    exit(1);
}

int getValueFromMap(const char *key)
{
    for (int i = 0; i < MAX_SIZE; ++i) {
        if (myMap[i].key[0] != '\0' && strcmp(myMap[i].key, key) == 0)
            return myMap[i].value;
    }
    return -1;
}
%}

%option yylineno

%%

"int"        { return INT; }
"if"         { return IF; }
"else"       { return ELSE; }
"end"        { return END; }
"print"      { return PRINT; }
"=="|"!="|"<="|">=" { yylval.sval = strdup(yytext); return OP; }
"<"|">"             { yylval.sval = strdup(yytext); return OP; }

[a-zA-Z][a-zA-Z0-9_]* {
    int id = getValueFromMap(yytext);
    if (id == -1) {
        num_of_v++;
        addToMap(yytext, num_of_v);
        yylval.ival = num_of_v;
    } else {
        yylval.ival = id;
    }
    return VARIABLE;
}

[0-9]+ {
    yylval.ival = atoi(yytext);
    return INTEGER;
}

"="     { return '='; }   /* assignment / equality handled by OP/lex earlier */
":"     { return ':'; }
";"     { return ';'; }
"("     { return '('; }
")"     { return ')'; }
"{"     { return '{'; }
"}"     { return '}'; }
"+"     { return '+'; }
"-"     { return '-'; }
"*"     { return '*'; }
"/"     { return '/'; }

[ \t\r\f\v]+   { /* ignore */ }

\n             { /* ignore newline */ }

.              { yyerror("invalid character"); }

%%

int yywrap(void) { return 1; }
